<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>The End Of Rings Around Plain Java - A Better Concurrency Test &middot; </title>

  
  <link rel="stylesheet" href="http://chasethedevil.github.io/css/poole.css">
  <link rel="stylesheet" href="http://chasethedevil.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://chasethedevil.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://chasethedevil.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://chasethedevil.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://chasethedevil.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=UnifrakturMaguntia:400,700">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://chasethedevil.github.io/touch-icon-144-precomposed.png">
  <link href="http://chasethedevil.github.io/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="">
  <meta name="keywords" content="">
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-365717-1', 'auto');
    ga('send', 'pageview');
  </script>
  
<script type="text/javascript"
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<link href=' http://fonts.googleapis.com/css?family=UnifrakturMaguntia' rel='stylesheet' type='text/css'>
</head>
<body class="theme-base-00">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
      <h1>Chase the Devil</h1>
      <p class="lead">Technical blog for Fabien.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://chasethedevil.github.io/">Blog</a></li>
      
      <li class="sidebar-nav-item"><a href="http://chasethedevil.github.io/about/">About</a></li>
      
      <li class="sidebar-nav-item"><a href="http://chasethedevil.github.io/post/">Posts</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <script type="text/javascript">document.write("<a href=\"mail" + "to:" + new Array("fabien","2ipi.com").join("@") + "?subject=your%20blog\">" + '<i class="fa fa-envelope fa-3x"></i>' + "</" + "a>");</script>  
      
      
      
      
      
      
      <a href="https://twitter.com/logos01"><i class="fa fa-twitter-square fa-3x"></i></a>
      
      <a href="http://chasethedevil.github.io/index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-3x"></i></a>
      </li>
    </ul>

    

    
  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">The End Of Rings Around Plain Java - A Better Concurrency Test</h1>
    <span class="post-date">Jan 15, 2009 &middot; 4 minute read &middot; <a href="http://chasethedevil.github.io/post/the-end-of-rings-around-plain-java---a-better-concurrency-test/#disqus_thread">Comments</a>
    </span>
    <p>In my <a href="http://chasethedevil.blogspot.com/2009/01/running-rings-around-plain-java-killer.html">previous post</a>, I was wondering why single thread was faster. D Andreou gave the correct explanation: as we send only 1 start message and as each node only send 1 message to the next one, there is always only 1 message being processed. So the test is optimum on 1 thread. It does not make much sense to make a multithreading benchmark on a problem that is fundamentally single threaded.</P> <P STYLE="margin-bottom: 0in"><BR> </P> <P STYLE="margin-bottom: 0in">His suggestion was to simple send N start messages where N &gt;= number of processors. In theory, the performance will become optimal with N threads then. Unfortunately this is not what happened in real life. In real life the single threaded performance is still better if you send even 16 messages on a biprocessor machine.  </P> <font face="monospace"> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">public</font>&nbsp;<font color="#00ff00">static</font>&nbsp;<font color="#00ff00">void</font>&nbsp;main(String[]&nbsp;args)&nbsp;<font color="#00ff00">throws</font>&nbsp;Exception {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OptimizedRing ring = <font color="#ffff00">new</font>&nbsp;OptimizedRing();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RingNode node = ring.startRing(Integer.parseInt(args[<font color="#ff6060">0</font>]));<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.sendMessage(<font color="#ffff00">new</font>&nbsp;StartMessage());<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.sendMessage(<font color="#ffff00">new</font>&nbsp;TokenMessage(node.nodeId,<font color="#ff6060">1</font>));<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.sendMessage(<font color="#ffff00">new</font>&nbsp;TokenMessage(node.nodeId,<font color="#ff6060">1</font>));<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.sendMessage(<font color="#ffff00">new</font>&nbsp;TokenMessage(node.nodeId,<font color="#ff6060">1</font>));<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ring.executor.awaitTermination(<font color="#ff6060">10</font>, TimeUnit.MINUTES);<br> &nbsp;&nbsp;&nbsp;&nbsp;}<br></font> <P STYLE="margin-bottom: 0in">My idea was that it was related to the swiching from thread to thread overhead, which is precisely what I think the original author of the test had in mind to test. I am not 100% convinced it is really what&rsquo;s happening. I wanted a test that would actually be faster using N threads; so I decided to add a bit of computation at before processing each Token. Unfortunately I had the bad idea to compute Pi by Monte Carlo method to do that. Running my tests I was surprised it did not change the results, and made things worse the most computer intensive the computation was (increasing the number of monte carlo iterations). It scared me a bit wondering what the hell could be wrong there. The following class performs much worse with 2 threads compared to 1:</P> <span style="text-foreground:#000000, text:#ffffff"> <font face="monospace"> <font color="#00ff00">public</font>&nbsp;<font color="#00ff00">class</font>&nbsp;BadParallelPi {<br> <br> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">private</font>&nbsp;<font color="#00ff00">static</font>&nbsp;<font color="#00ff00">void</font>&nbsp;startExecutors()&nbsp;<font color="#00ff00">throws</font>&nbsp;Exception {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">long</font>&nbsp;startTime = System.currentTimeMillis();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(startTime);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecutorService executor1 = Executors.newFixedThreadPool(<font color="#ff6060">1</font>);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1.execute(<font color="#ffff00">new</font>&nbsp;Computation());<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1.execute(<font color="#ffff00">new</font>&nbsp;Computation());<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1.shutdown();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1.awaitTermination(<font color="#ff6060">60</font>, TimeUnit.SECONDS);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">long</font>&nbsp;delay = System.currentTimeMillis()&nbsp;- startTime;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<font color="#ff6060">&quot;finished single thread in &quot;</font>+(delay/<font color="#ff6060">1000.0</font>));<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startTime = System.currentTimeMillis();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(startTime);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1 = Executors.newFixedThreadPool(<font color="#ff6060">2</font>);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1.execute(<font color="#ffff00">new</font>&nbsp;Computation());<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1.execute(<font color="#ffff00">new</font>&nbsp;Computation());<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1.shutdown();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor1.awaitTermination(<font color="#ff6060">60</font>, TimeUnit.SECONDS);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay = System.currentTimeMillis()&nbsp;- startTime;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<font color="#ff6060">&quot;finished 2 threads in &quot;</font>+(delay/<font color="#ff6060">1000.0</font>)); <br> &nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">public</font>&nbsp;<font color="#00ff00">static</font>&nbsp;<font color="#00ff00">class</font>&nbsp;Computation <font color="#00ff00">implements</font>&nbsp;Runnable {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">public</font>&nbsp;<font color="#00ff00">volatile</font>&nbsp;<font color="#00ff00">int</font>&nbsp;count = <font color="#ff6060">0</font>;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#00ff00">private</font>&nbsp;<font color="#00ff00">double</font>&nbsp;computePi()&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">double</font>&nbsp;pi = <font color="#ff6060">0</font>;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">double</font>&nbsp;x,y;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">int</font>&nbsp;n = <font color="#ff6060">10000000</font>;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ffff00">for</font>&nbsp;(<font color="#00ff00">int</font>&nbsp;i=<font color="#ff6060">0</font>;i&lt;n;i++)&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = Math.random();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x *= x;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = Math.random();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y *= y;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ffff00">if</font>&nbsp;(x+y &lt; <font color="#ff6060">1</font>)&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi +=<font color="#ff6060">1</font>;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi = <font color="#ff6060">4</font>*pi/n;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ffff00">return</font>&nbsp;pi;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">public</font>&nbsp;<font color="#00ff00">void</font>&nbsp;run()&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">double</font>&nbsp;pi = computePi();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">long</font>&nbsp;time = System.currentTimeMillis();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(time+<font color="#ff6060">&quot; thread &quot;</font>+Thread.currentThread().getId()+<font color="#ff6060">&quot; pi=&quot;</font>+pi);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;}<br> <br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#00ff00">public</font>&nbsp;<font color="#00ff00">static</font>&nbsp;<font color="#00ff00">void</font>&nbsp;main(String[]&nbsp;args)&nbsp;<font color="#00ff00">throws</font>&nbsp;Exception {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startExecutors();<br> &nbsp;&nbsp;&nbsp;&nbsp;}<br> } </font></span> <P STYLE="margin-bottom: 0in">Did you figure out why?</P> <P STYLE="margin-bottom: 0in"><BR> </P> <P STYLE="margin-bottom: 0in">It took me less time with this simple code than with the original ring test to find out why. It is simply because of the Math.random call. Math.random only creates one random number generator, and it will be shared among threads. So every thread will wait at the other one at this point. Creating one random generator per thread showed 2 threads were much faster than 1, finally.</P> <P STYLE="margin-bottom: 0in"><BR> </P> <P STYLE="margin-bottom: 0in">Back to the original ring test. Adding the correct way to compute Pi by Monte Carlo, I now had decent test results as long as the number of iterations is not too small. 10 iterations is enough to show a real difference between N threads and 1. Adding a small computation helps figuring out what happens behind the scene. You can also verify D Andreou claim, using only 1 start message the single threaded version is faster. If computation is too weak (for example number of Monte Carlo iteration of 0,  one only measures method calls between threads (context switching), which is obviously optimal for 1 thread. Measuring Actor libraries on it is dangerous: if I write a single threaded Actor library, it will be the fastest of this test, but it certainly is not what you want to use as Actor library.</P> <P STYLE="margin-bottom: 0in"><BR>Let&rsquo;s see now how Scala fares compared to the Plain Java solution, using computation: <TABLE WIDTH=681 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0 RULES=NONE>  <COL WIDTH=79>  <COL WIDTH=173>  <COL WIDTH=145>  <COL WIDTH=250>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=10>    <P ALIGN=LEFT>Machine</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>Algorithm</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT>Time for 100000 ring count, 10 mc, 4 messages</P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT>Time for 10000 ring count, 100 mc, 4 messages</P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=11>    <P ALIGN=LEFT>Core2Duo</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>OptimizedRing 2 Threads</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT><SPAN STYLE="background: #ffff00">57s</SPAN></P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT>37s</P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=11>    <P ALIGN=LEFT>Core2Duo</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>OptimizedRing 4 Threads</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT>78s</P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT>39s</P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=11>    <P ALIGN=LEFT>Core2Duo</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>Scala Actors</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT><SPAN STYLE="background: #00ff00">82s</SPAN></P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT>47s</P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=11>    <P ALIGN=LEFT>Core2Duo</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>SimpleRing (100 Threads)</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT><SPAN STYLE="background: #ff0000">137s</SPAN></P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT><SPAN STYLE="background: #ff0000">58s</SPAN></P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=11>    <P ALIGN=LEFT>Core2Duo</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>OptimizedRing 1 Thread</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT>89s</P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT>71s</P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=11>    <P ALIGN=LEFT>Core2Quad</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>OptimizedRing 4 Threads</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT>81s</P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT><SPAN STYLE="background: #ffff00">25s</SPAN></P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=11>    <P ALIGN=LEFT>Core2Quad</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>Scala Actors</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT>71s</P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT><SPAN STYLE="background: #00ff00">30s</SPAN></P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=11>    <P ALIGN=LEFT>Core2Quad</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>OptimizedRing 2 Threads</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT>61s</P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT>43s</P>   </TD>  </TR>  <TR VALIGN=BOTTOM>   <TD WIDTH=79 HEIGHT=10>    <P ALIGN=LEFT>Core2Quad</P>   </TD>   <TD WIDTH=173>    <P ALIGN=LEFT>OptimizedRing 1 Threads</P>   </TD>   <TD WIDTH=145>    <P ALIGN=LEFT>100s</P>   </TD>   <TD WIDTH=250>    <P ALIGN=LEFT>80s</P>   </TD>  </TR> </TABLE> </P> The Core2Duo is Intel&reg; Core&trade;2 Duo CPU     T7250  @ 2.00GHz <BR>The Core2Quad is Intel&reg; Core&trade;2 Quad CPU    Q6600  @ 2.40GHz <BR><BR> It is interesting to compare results of 4 threads on a biprocessor with monte carlo count of 10 and 100. We see a much higher thread overhead with fewer computation. With too few computation in monte carlo, the overhead of threads is too high over 2 concurrent threads. This explains why the very simple threading architecture fares much better in the last column compared to the previous one. <BR><BR> Scala Actors fares much better when it is not hindered in the creation of too many threads. It seem actually very good at abstracting multithreading intricacies, while still providing near Java performance in the real world where each actor does enough computation and multithreading is important.</p>

  </div>
   <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "chasethedevil";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "chasethedevil";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<div class="content container" style="padding-top: 0rem;"-->
 <a href="https://twitter.com/share" class="twitter-share-button"{count} data-hashtags="chasethedevil" data-size="large">Tweet</a>
 <a style="font-size:75%;" href="//www.reddit.com/submit" onclick="window.location = '//www.reddit.com/submit?url=' + encodeURIComponent(window.location); return false"><i class="fa fa-reddit fa-2x" aria-hidden="true"></i>Submit to reddit</a> 
<table style="border-collapse: collapse;">
     <tr style="padding: 0px; margin: 0px; border: none;">
     <td style="vertical-align: middle;padding: 0px; margin: 0px; border: none;font-size: 60%;">&copy; 2006-16 <a href="http://chasethedevil.github.io/about/">Fabien</a></td>
     <td style="vertical-align: middle;padding: 0px; margin: 0px; border: none;font-size: 0px;"><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="padding: 0px; margin: 0px; border: none;" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a></td>
     <td style="vertical-align: middle;padding: 0px; margin: 0px; border: none;font-size: 60%;">This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</td></tr></table>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
</div>
<script src="http://chasethedevil.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script>
  var _gaq=[['_setAccount','UA-365717-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>

