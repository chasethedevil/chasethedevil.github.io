<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.83.1" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>The End Of Rings Around Plain Java - A Better Concurrency Test &middot; Chase the Devil</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">
<link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&display=swap" rel="stylesheet">
 <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://chasethedevil.github.io/"><h1 style="font-family: 'UnifrakturMaguntia', cursive;font-weight: normal;">Chase the Devil</h1></a>
      <p class="lead">
       A personal, independent, technical blog 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://chasethedevil.github.io/">Blog</a> </li>
        <li><a href="/about/"> About </a></li><li><a href="/post/"> Posts </a></li>
      </ul>

        <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <script type="text/javascript">document.write("<a href=\"mail" + "to:" + new Array("fabien","2ipi.com").join("@") + "?subject=your%20blog\">" + '<i class="fa fa-envelope fa-3x"></i>' + "</" + "a>");</script>
      
      
      
      
      
      
      <a href="https://twitter.com/logos01"><i class="fa fa-twitter-square fa-3x"></i></a>
      
      <a href="https://chasethedevil.github.io/index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-3x"></i></a>
      </li>
    </ul>
 </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>The End Of Rings Around Plain Java - A Better Concurrency Test</h1>
  <time datetime=2009-01-15T15:54:00Z class="post-date">Thu, Jan 15, 2009</time>
  <p>In my <!-- raw HTML omitted -->previous post<!-- raw HTML omitted -->, I was wondering why single thread was faster. D Andreou gave the correct explanation: as we send only 1 start message and as each node only send 1 message to the next one, there is always only 1 message being processed. So the test is optimum on 1 thread. It does not make much sense to make a multithreading benchmark on a problem that is fundamentally single threaded.<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted -->His suggestion was to simple send N start messages where N &gt;= number of processors. In theory, the performance will become optimal with N threads then. Unfortunately this is not what happened in real life. In real life the single threaded performance is still better if you send even 16 messages on a biprocessor machine.  <!-- raw HTML omitted --> <!-- raw HTML omitted -->     <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->static<!-- raw HTML omitted --> <!-- raw HTML omitted -->void<!-- raw HTML omitted --> main(String[] args) <!-- raw HTML omitted -->throws<!-- raw HTML omitted --> Exception {<!-- raw HTML omitted -->         OptimizedRing ring = <!-- raw HTML omitted -->new<!-- raw HTML omitted --> OptimizedRing();<!-- raw HTML omitted -->         RingNode node = ring.startRing(Integer.parseInt(args[<!-- raw HTML omitted -->0<!-- raw HTML omitted -->]));<!-- raw HTML omitted -->         node.sendMessage(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> StartMessage());<!-- raw HTML omitted -->         node.sendMessage(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> TokenMessage(node.nodeId,<!-- raw HTML omitted -->1<!-- raw HTML omitted -->));<!-- raw HTML omitted -->         node.sendMessage(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> TokenMessage(node.nodeId,<!-- raw HTML omitted -->1<!-- raw HTML omitted -->));<!-- raw HTML omitted -->         node.sendMessage(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> TokenMessage(node.nodeId,<!-- raw HTML omitted -->1<!-- raw HTML omitted -->));<!-- raw HTML omitted -->         ring.executor.awaitTermination(<!-- raw HTML omitted -->10<!-- raw HTML omitted -->, TimeUnit.MINUTES);<!-- raw HTML omitted -->     }<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->My idea was that it was related to the swiching from thread to thread overhead, which is precisely what I think the original author of the test had in mind to test. I am not 100% convinced it is really what&rsquo;s happening. I wanted a test that would actually be faster using N threads; so I decided to add a bit of computation at before processing each Token. Unfortunately I had the bad idea to compute Pi by Monte Carlo method to do that. Running my tests I was surprised it did not change the results, and made things worse the most computer intensive the computation was (increasing the number of monte carlo iterations). It scared me a bit wondering what the hell could be wrong there. The following class performs much worse with 2 threads compared to 1:<!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->class<!-- raw HTML omitted --> BadParallelPi {<!-- raw HTML omitted --> <!-- raw HTML omitted -->     <!-- raw HTML omitted -->private<!-- raw HTML omitted --> <!-- raw HTML omitted -->static<!-- raw HTML omitted --> <!-- raw HTML omitted -->void<!-- raw HTML omitted --> startExecutors() <!-- raw HTML omitted -->throws<!-- raw HTML omitted --> Exception {        <!-- raw HTML omitted -->         <!-- raw HTML omitted -->long<!-- raw HTML omitted --> startTime = System.currentTimeMillis();<!-- raw HTML omitted -->         System.out.println(startTime);<!-- raw HTML omitted -->         ExecutorService executor1 = Executors.newFixedThreadPool(<!-- raw HTML omitted -->1<!-- raw HTML omitted -->);<!-- raw HTML omitted -->         executor1.execute(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> Computation());<!-- raw HTML omitted -->         executor1.execute(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> Computation());<!-- raw HTML omitted -->         executor1.shutdown();<!-- raw HTML omitted -->         executor1.awaitTermination(<!-- raw HTML omitted -->60<!-- raw HTML omitted -->, TimeUnit.SECONDS);<!-- raw HTML omitted -->         <!-- raw HTML omitted -->long<!-- raw HTML omitted --> delay = System.currentTimeMillis() - startTime;<!-- raw HTML omitted -->         System.out.println(<!-- raw HTML omitted -->&quot;finished single thread in &quot;<!-- raw HTML omitted -->+(delay/<!-- raw HTML omitted -->1000.0<!-- raw HTML omitted -->));<!-- raw HTML omitted -->         startTime = System.currentTimeMillis();<!-- raw HTML omitted -->         System.out.println(startTime);<!-- raw HTML omitted -->         executor1 = Executors.newFixedThreadPool(<!-- raw HTML omitted -->2<!-- raw HTML omitted -->);<!-- raw HTML omitted -->         executor1.execute(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> Computation());<!-- raw HTML omitted -->         executor1.execute(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> Computation());<!-- raw HTML omitted -->         executor1.shutdown();<!-- raw HTML omitted -->         executor1.awaitTermination(<!-- raw HTML omitted -->60<!-- raw HTML omitted -->, TimeUnit.SECONDS);<!-- raw HTML omitted -->         delay = System.currentTimeMillis() - startTime;<!-- raw HTML omitted -->         System.out.println(<!-- raw HTML omitted -->&quot;finished 2 threads in &quot;<!-- raw HTML omitted -->+(delay/<!-- raw HTML omitted -->1000.0<!-- raw HTML omitted -->)); <!-- raw HTML omitted -->     }<!-- raw HTML omitted -->     <!-- raw HTML omitted -->     <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->static<!-- raw HTML omitted --> <!-- raw HTML omitted -->class<!-- raw HTML omitted --> Computation <!-- raw HTML omitted -->implements<!-- raw HTML omitted --> Runnable {<!-- raw HTML omitted -->         <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->volatile<!-- raw HTML omitted --> <!-- raw HTML omitted -->int<!-- raw HTML omitted --> count = <!-- raw HTML omitted -->0<!-- raw HTML omitted -->;<!-- raw HTML omitted -->          <!-- raw HTML omitted -->private<!-- raw HTML omitted --> <!-- raw HTML omitted -->double<!-- raw HTML omitted --> computePi() {<!-- raw HTML omitted -->             <!-- raw HTML omitted -->double<!-- raw HTML omitted --> pi = <!-- raw HTML omitted -->0<!-- raw HTML omitted -->;<!-- raw HTML omitted -->             <!-- raw HTML omitted -->double<!-- raw HTML omitted --> x,y;<!-- raw HTML omitted -->             <!-- raw HTML omitted -->int<!-- raw HTML omitted --> n = <!-- raw HTML omitted -->10000000<!-- raw HTML omitted -->;<!-- raw HTML omitted -->             <!-- raw HTML omitted -->for<!-- raw HTML omitted --> (<!-- raw HTML omitted -->int<!-- raw HTML omitted --> i=<!-- raw HTML omitted -->0<!-- raw HTML omitted -->;i&lt;n;i++) {<!-- raw HTML omitted -->                 x = Math.random();<!-- raw HTML omitted -->                 x *= x;<!-- raw HTML omitted -->                 y = Math.random();<!-- raw HTML omitted -->                 y *= y;<!-- raw HTML omitted -->                 <!-- raw HTML omitted -->if<!-- raw HTML omitted --> (x+y &lt; <!-- raw HTML omitted -->1<!-- raw HTML omitted -->) {<!-- raw HTML omitted -->                     pi +=<!-- raw HTML omitted -->1<!-- raw HTML omitted -->;<!-- raw HTML omitted -->                 }<!-- raw HTML omitted -->             }<!-- raw HTML omitted -->             pi = <!-- raw HTML omitted -->4<!-- raw HTML omitted -->*pi/n;<!-- raw HTML omitted -->             <!-- raw HTML omitted -->return<!-- raw HTML omitted --> pi;<!-- raw HTML omitted -->         }<!-- raw HTML omitted -->         <!-- raw HTML omitted -->         <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->void<!-- raw HTML omitted --> run() {<!-- raw HTML omitted -->             <!-- raw HTML omitted -->double<!-- raw HTML omitted --> pi = computePi();<!-- raw HTML omitted -->             <!-- raw HTML omitted -->long<!-- raw HTML omitted --> time = System.currentTimeMillis();<!-- raw HTML omitted -->             System.out.println(time+<!-- raw HTML omitted -->&quot; thread &quot;<!-- raw HTML omitted -->+Thread.currentThread().getId()+<!-- raw HTML omitted -->&quot; pi=&quot;<!-- raw HTML omitted -->+pi);<!-- raw HTML omitted -->             count++;<!-- raw HTML omitted -->         }        <!-- raw HTML omitted -->     }<!-- raw HTML omitted --> <!-- raw HTML omitted -->     <!-- raw HTML omitted -->     <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->static<!-- raw HTML omitted --> <!-- raw HTML omitted -->void<!-- raw HTML omitted --> main(String[] args) <!-- raw HTML omitted -->throws<!-- raw HTML omitted --> Exception {<!-- raw HTML omitted -->         startExecutors();<!-- raw HTML omitted -->     }<!-- raw HTML omitted --> } <!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->Did you figure out why?<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted -->It took me less time with this simple code than with the original ring test to find out why. It is simply because of the Math.random call. Math.random only creates one random number generator, and it will be shared among threads. So every thread will wait at the other one at this point. Creating one random generator per thread showed 2 threads were much faster than 1, finally.<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted -->Back to the original ring test. Adding the correct way to compute Pi by Monte Carlo, I now had decent test results as long as the number of iterations is not too small. 10 iterations is enough to show a real difference between N threads and 1. Adding a small computation helps figuring out what happens behind the scene. You can also verify D Andreou claim, using only 1 start message the single threaded version is faster. If computation is too weak (for example number of Monte Carlo iteration of 0,  one only measures method calls between threads (context switching), which is obviously optimal for 1 thread. Measuring Actor libraries on it is dangerous: if I write a single threaded Actor library, it will be the fastest of this test, but it certainly is not what you want to use as Actor library.<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->Let&rsquo;s see now how Scala fares compared to the Plain Java solution, using computation: <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Machine<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Algorithm<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Time for 100000 ring count, 10 mc, 4 messages<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Time for 10000 ring count, 100 mc, 4 messages<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 2 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->57s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->37s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 4 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->78s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->39s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Scala Actors<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->82s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->47s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->SimpleRing (100 Threads)<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->137s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->58s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 1 Thread<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->89s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->71s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Quad<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 4 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->81s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->25s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Quad<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Scala Actors<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->71s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->30s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Quad<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 2 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->61s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->43s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Quad<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 1 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->100s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->80s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted --> The Core2Duo is Intel(R) Core(TM)2 Duo CPU     T7250  @ 2.00GHz <!-- raw HTML omitted -->The Core2Quad is Intel(R) Core(TM)2 Quad CPU    Q6600  @ 2.40GHz <!-- raw HTML omitted --><!-- raw HTML omitted --> It is interesting to compare results of 4 threads on a biprocessor with monte carlo count of 10 and 100. We see a much higher thread overhead with fewer computation. With too few computation in monte carlo, the overhead of threads is too high over 2 concurrent threads. This explains why the very simple threading architecture fares much better in the last column compared to the previous one. <!-- raw HTML omitted --><!-- raw HTML omitted --> Scala Actors fares much better when it is not hindered in the creation of too many threads. It seem actually very good at abstracting multithreading intricacies, while still providing near Java performance in the real world where each actor does enough computation and multithreading is important.</p>

</div>

<h2>Comments</h2>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "chasethedevil" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </main>

    
      
    
  </body>
</html>
