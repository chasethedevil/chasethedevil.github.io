<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.83.1" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Chase the Devil</title>
  <meta name="description" content="A personal, independent, technical blog" />

  
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">
<link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&display=swap" rel="stylesheet">
 <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://chasethedevil.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Chase the Devil" />
  <script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://chasethedevil.github.io/"><h1 style="font-family: 'UnifrakturMaguntia', cursive;font-weight: normal;">Chase the Devil</h1></a>
      <p class="lead">
       A personal, independent, technical blog 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://chasethedevil.github.io/">Blog</a> </li>
        <li><a href="/about/"> About </a></li><li><a href="/post/"> Posts </a></li>
      </ul>

        <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <script type="text/javascript">document.write("<a href=\"mail" + "to:" + new Array("fabien","2ipi.com").join("@") + "?subject=your%20blog\">" + '<i class="fa fa-envelope fa-3x"></i>' + "</" + "a>");</script>
      
      
      
      
      
      
      <a href="https://twitter.com/logos01"><i class="fa fa-twitter-square fa-3x"></i></a>
      
      <a href="https://chasethedevil.github.io/index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-3x"></i></a>
      </li>
    </ul>
 </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/heston-or-schobel-zhu-issues-with-short-expiries/">Heston or Schobel-Zhu issues with short expiries</a>
  </h1>
  <time datetime="2014-07-03T23:28:00Z" class="post-date">Thu, Jul 3, 2014</time>
  <p>It&rsquo;s relatively well known that Heston does not fit the market for short expiries. Given that there are just 5 parameters to fit a full surface, it&rsquo;s almost logical that one part of the surface of it is not going to fit well the market.<!-- raw HTML omitted -->I was more surprised to see how bad Heston or Schobel-Zhu were to fit a single short expiry volatility slice. As an example I looked at SP500 options with 1 week expiry. It does not really matter if one forces kappa and rho to constant values (even to 0) the behavior is the same and the error in fit does not change much.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Schobel-Zhu fit for a slice of maturity 1 week<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->In this graph, the brown, green and red smiles corresponds to Schobel-Zhu fit using an explicit guess (matching skew &amp; curvature ATM), using Levenberg-Marquardt on this guess, and using plain differential evolution. <!-- raw HTML omitted -->What happens is that the smiles flattens to quickly in the strike dimension. One consequence is that the implied volatility can not be computed for extreme strikes: the smile being too low, the price becomes extremely small, under machine epsilon and the numerical method (Cos) fails. There is also a bogus angle in the right wing, because of numerical error. I paid attention to ignore too small prices in the calibration by truncating the initial data.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Heston fit, with Lord-Kahl (exact wings)<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->SABR behaves much better (fixing beta=1 in this case) in comparison (As I use the same truncation as for Schobel-Zhu, the flat left wing part is ignored). <!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->SABR fit for a slice of maturity 1 week<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->For longer expiries, Heston &amp; Schobel-Zhu, even limited to 3 parameters, actually give a better fit in general than SABR.</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/on-the-role-of-static-types-and-generic-types-on-productivity/">On the Role of Static Types and Generic Types on Productivity</a>
  </h1>
  <time datetime="2014-06-29T10:40:00Z" class="post-date">Sun, Jun 29, 2014</time>
  <p>Most developers have strong opinions on dynamic types programming languages vs static types programming languages. The former is often assumed to be good for small projects/prototyping while the later better for bigger projects. But there is a surprisingly small number of studies to back those claims.<!-- raw HTML omitted --><!-- raw HTML omitted -->One such study is &ldquo;<!-- raw HTML omitted -->An experiment about static and dynamic type systems: doubts about the positive impact of static type systems on development time<!-- raw HTML omitted -->&rdquo; and came to the conclusion that on a small project, static typing did not decrease programming time, and actually increased debugging time. However 4 years later, &ldquo;<!-- raw HTML omitted -->An empirical comparison of static and dynamic type systems on API usage in the presence of an IDE: Java vs. groovy with eclipse<!-- raw HTML omitted -->&rdquo; shows that a developer is 2x more productive with Java than with Groovy using an unknown API. This contrasts a bit (but does not contradict) with their previous study &ldquo;<!-- raw HTML omitted -->Static Type Systems (Sometimes) have a Positive Impact on the Usability of Undocumented Software: An Empirical Evaluation<!-- raw HTML omitted -->&rdquo; that showed Groovy to be more productive on small projects. One problem is that all these studies stem from the same person.<!-- raw HTML omitted --><!-- raw HTML omitted -->It&rsquo;s more interesting to look at generic types vs raw types use, where even less studies have been done. &ldquo;<!-- raw HTML omitted -->Do developers benefit from generic types?: an empirical comparison of generic and raw types in java<!-- raw HTML omitted -->&rdquo; concludes that generic types do not provide any advantages to fix typing errors, hardly surprising in my opinion. Generic types (especially with type erasure as in Java) is the typical idea that sounds good but that in practice does not really help: it makes the code actually more awkward to read and tend to make developers too lazy to create new classes that would often be more appropriate than a generic type (think Map&lt;String,List&lt;Map&lt;String, Date&gt;&gt;&gt;).</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/moore-penrose-inverse-gauss-newton-sabr-minimization/">Moore-Penrose Inverse &amp; Gauss-Newton SABR Minimization</a>
  </h1>
  <time datetime="2014-06-24T15:29:00Z" class="post-date">Tue, Jun 24, 2014</time>
  <p>I have found a particularly nice initial guess to calibrate SABR. As it is quite close to the true best fit, it is tempting to use a very simple minimizer to go to the best fit. Levenberg-Marquardt works well on this problem, but can we shave off a few iterations?<!-- raw HTML omitted --><!-- raw HTML omitted -->I firstly considered the basic <!-- raw HTML omitted -->Newton&rsquo;s method<!-- raw HTML omitted -->, but for least squares minimization, the Hessian (second derivatives) is needed. It&rsquo;s possible to obtain it, even analytically with SABR, but it&rsquo;s quite annoying to derive it and code it without some automatic differentiation tool. It turns out that as I experimented with the numerical Hessian, I noticed that it actually did not help convergence in our problem. <!-- raw HTML omitted -->Gauss-Newton<!-- raw HTML omitted --> converges similarly (likely because the initial guess is good), and what&rsquo;s great about it is that you just need the Jacobian (first derivatives). <!-- raw HTML omitted -->Here<!-- raw HTML omitted --> is a good overview of Newton, Gauss-Newton and Levenberg-Marquardt methods.<!-- raw HTML omitted --><!-- raw HTML omitted -->While Gauss-Newton worked on many input data, I noticed it failed also on some long maturities equity smiles. The full Newton&rsquo;s method did not fare  better. I had to take a close look at the matrices involved to understand what was going on. It turns out that sometimes, mostly when the SABR rho parameter is close to -1, the Jacobian would be nearly rank deficient (a row close to 0), but not exactly rank deficient. So everything would appear to work, but it actually misbehaves badly.<!-- raw HTML omitted --><!-- raw HTML omitted -->My first idea was to solve the reduced problem if a row of the Jacobian is too small, by just removing that row, and keep the previous value for the guess corresponding to that row. And this simplistic approach made the process work on all my input data. Here is the difference in RMSE compared to a highly accurate Levenberg-Marquardt minimization for 10 iterations:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Later, while reading some more material related to least square optimization, I noticed the use of the <!-- raw HTML omitted -->Moore-Penrose inverse<!-- raw HTML omitted --> in cases where a matrix is rank deficient. The Moore-Penrose inverse is defined as:<!-- raw HTML omitted -->$$ M^\star = V S^\star U^T$$<!-- raw HTML omitted -->where ( S^\star ) is the diagonal matrix with inverted eigenvalues and 0 if those are deemed numerically close to 0, and (U, V) the eigenvectors of the SVD decomposition:<!-- raw HTML omitted -->$$M=U S V^T$$<!-- raw HTML omitted -->It turns out to work very well, beside being simpler to code, I expected it to be more or less equivalent to the previous approach (a tiny bit slower but we don&rsquo;t care as we deal with small matrices, and the real slow part is the computation of the objective function and the Hessian, which is why looking at iterations is more important).<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->It seems to converge a little bit less quickly, likely due to the threshold criteria that I picked (1E-15).<!-- raw HTML omitted -->Three iterations is actually most of the time (90%) more than enough to achieve a good accuracy (the absolute RMSE is between 1E-4 and 5E-2) as the following graph shows. The few spikes near 1E-3 represent too large errors, the rest is accurate enough compared to the absolute RMSE.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->To conclude, we have seen that using the Moore-Penrose inverse in a Gauss-Newton iteration allowed the Gauss-Newton method to work on rank-deficient systems.<!-- raw HTML omitted -->I am not sure how general that is, in my example, the true minimum either lies inside the region of interest, or on the border, where the system becomes deficient. Of course, this is related to a &ldquo;physical&rdquo; constraint, here namely rho &gt; -1.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/one-interview-question-for-job-seekers-in-finance/">One Interview Question for Job Seekers in Finance</a>
  </h1>
  <time datetime="2014-06-19T21:51:00Z" class="post-date">Thu, Jun 19, 2014</time>
  <p>I presented in an <!-- raw HTML omitted -->earlier post<!-- raw HTML omitted --> that I was mostly disillusioned with interview questions, it&rsquo;s better to find out if you can learn something out of a candidate.<!-- raw HTML omitted --><!-- raw HTML omitted -->Well there is maybe one very simple question that could be revealing, for people who pretend to be vaguely familiar with Black-Scholes:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->What is the price of an at-the-money  binary option under very high volatility? <!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Alternatively it can be asked with just an at-the-money european option under very high volatility.<!-- raw HTML omitted --><!-- raw HTML omitted -->What makes think of it is that some &ldquo;product manager&rdquo; recently tested risk with volatilities at 300% and was wondering why they did not see any vega (based on a 1% additive shift), and opened bugs, generated noise&hellip;</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/on-the-importance-of-accuracy-for-bpvol-solvers/">On the importance of accuracy for bpvol solvers</a>
  </h1>
  <time datetime="2014-06-12T17:31:00Z" class="post-date">Thu, Jun 12, 2014</time>
  <p>While I was playing around calibrating the arbitrage free SABR model from Hagan (using the PDE on probability density approach), I noticed a misbehavior for some short maturity smiles. I thought it was due to the PDE implementation. Actually some of it was, but the remaining large error was due to the bpvol solver.<!-- raw HTML omitted --><!-- raw HTML omitted -->I initially took the same approach as Choi et al. in <!-- raw HTML omitted -->my solver<!-- raw HTML omitted -->, that is to work with in-the-money prices (they work with straddles) because it&rsquo;s nice and convenient. I thought it was no big deal if prices lower than 1E-16 were not solved. It turns out I was wrong. Choi et al. solver has the same issue.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->In the above figure, CKK denotes the Choi et al algorithm (similar with my old algorithm) and Chebyshev is my updated algorithm that is accurate with far out-of-the-money option. What happens is that even though the market price at the lowest strike is not very low, the price at the lowest strike stemming from the best fit smile is extremely low, and when we want to invert it, CKK produces a large error due to lack of representation of numbers near 1.0 as it uses indirectly the in-the-money price. That&rsquo;s where it introduces a particularly big error in this case.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->I have updated my solver since, to work with out-of-the-money option prices as well, and have near machine accuracy on the whole range. I also reduced the number of Chebyshev polynomials used in the process. All the details are in my updated paper at <!-- raw HTML omitted --><a href="http://papers.ssrn.com/abstract=2420757">http://papers.ssrn.com/abstract=2420757</a><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/throws-exception/">throws Exception</a>
  </h1>
  <time datetime="2014-05-27T10:49:00Z" class="post-date">Tue, May 27, 2014</time>
  <p>There was a big debate at work around Exception declaration in a Java API. I was quite surprised that such an apparently simple subject could end up being so controversial. The controversy was around the choice of declaring in the interfaces:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->void myMethod() throws Exception<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->instead of<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->void myMethod() throws MyAPIException<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->void myMethod() throws MyAPIRuntimeException<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->void myMethod() <!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->where MyAPI represents either a generic API related exception or a specific exception related to the method in question.<!-- raw HTML omitted --><!-- raw HTML omitted -->The choice of &ldquo;throws Exception&rdquo; did not even occur to me as a possibility, but after some digging, I found that some relatively famous libraries actually followed that principle at one point, for example Apache Struts 1.x or Spring MVC. <!-- raw HTML omitted --><!-- raw HTML omitted -->More modern libraries, like Google Guava, commons-math 3.x, Struts 2.x generally favor MyAPIRuntimeException where MyAPI is actually context-specific. Some old popular libraries declare a checked Exception, for example the HibernateException in Hibernate.<!-- raw HTML omitted --><!-- raw HTML omitted -->This seems to be a recurring subject on Stackoverflow:<!-- raw HTML omitted --><!-- raw HTML omitted -->Stackoverflow - Java interface throws Exception best practice<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Stackoverflow - What to put in the throws clause of an interface method<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->But those are quite poor in terms of explanations. The best comments on this subjects are from:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Anders         Hejlsberg (C#, Delphi, Turbo Pascal creator) - The Trouble with         Checked Exceptions<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->James         Gosling (Java creator) - Failure and Exceptions<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted -->This comment from Anders is particularly acute:<!-- raw HTML omitted -->    &ldquo;<!-- raw HTML omitted -->To work around this requirement, people do ridiculous things.       For example, they decorate every method with, &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->throws         Exception<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->.&rdquo; That just completely defeats the       feature, and you just made the programmer write more gobbledy       gunk. That doesn&rsquo;t help anybody.<!-- raw HTML omitted -->    &ldquo;<!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->         <!-- raw HTML omitted -->Today I believe the API in question declares &ldquo;throws Exception&rdquo;&hellip; <!-- raw HTML omitted -->         <!-- raw HTML omitted --><!-- raw HTML omitted --></p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/kde-xfce-gnome-shell-in-2014/">KDE, XFCE, Gnome-Shell in 2014</a>
  </h1>
  <time datetime="2014-05-25T09:26:00Z" class="post-date">Sun, May 25, 2014</time>
  <p>Many people (and notoriously, Linus Torvald) complained about Gnome-shell, especially the early iterations. Similarly KDE 4 was a nightmare of instability and inflexibility when it came out. And XFCE has always sounded a bit too basic. the moves of Gnome and KDE were particularly shocking as the earlier iteration: Gnome 2 and KDE 3 were well appreciated, productive environments.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Gnome Shell 3.10<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->It took me a bit of time to get used to it, and in the early stages I went to KDE 4 for a while, only to come back to it later.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Positive aspects:<!-- raw HTML omitted --> lots of space on the desktop, things don&rsquo;t get in the way, looks good,very good desktop overview (fast and well presented), a dock by default, great external monitor support (plug and play, remembers settings automatically), best OSD (volume) of all.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Negative aspects:<!-- raw HTML omitted --> the notifications bar looks awkward and badly integrated (better with an extension), still unstable and big memory leaks (on Fedora 20, where the integration should be the best, it regularly crashes, starts with 300Mb and goes up to 1Gb in a couple of days), fallback-session completely useless as one can not customize it at all. But the killer for my work was  inability to share the desktop with Webex, while XFCE could.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->KDE<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->I gave it a long try especially in 2012, it has not changed much in 2014. My opinion of it fell when I tried it a very short time after months of Gnome Shell, and even more so after seeing the trouble my parents had with it, compared to Gnome 2.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Positive aspects:<!-- raw HTML omitted --> desktop search (needs to be configured in order to scan only the relevant folders, used to be slow and resource intensive, not so much in 2014)<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Negative aspects:<!-- raw HTML omitted --> resource hog, awful start menu, too many shiny effects by default that only distract the user from his task, silly concepts like activities, every aspect of the desktop seems to require tweaking in non obvious ways for it to be more usable, looks ok but not great.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->XFCE<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->On Fedora, the default XFCE is very very basic, so much that I could hardly see a difference with one from 10 years ago. On Xubuntu, it&rsquo;s much much better. When I came to it from Gnome-Shell, I was surprised at how good was the &ldquo;old&rdquo; desktop paradigm for productivity. I also surprisingly found multiple desktops more natural to use than on Gnome Shell/KDE.<!-- raw HTML omitted -->On Fedora the way to make it like Xubuntu is to install elementary icons, the whisker menu and choose the greybird/bluebird themes.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->yum groups install &ldquo;Xfce Desktop&rdquo;<!-- raw HTML omitted -->yum install xfce4-mixer.x86_64 xfce4-whiskermenu-plugin.x86_64 xfce4-cpugraph-plugin.x86_64 xfce4-mount-plugin.x86_64 xfce4-icon-theme.noarch google-droid* elementary-xfce-icon-theme.noarch xfce4-volumed.x86_64 pavucontrol.x86_64<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Positive aspects:<!-- raw HTML omitted --> fast and lean, great start menu. <!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Negative aspects:<!-- raw HTML omitted --> external monitor support could be more automatic like Gnome-Shell, no nice overview of all windows, default installation can be a bit too bare, sometimes not sexy (volume applet is ugly, xubuntu provides the unity indicators in xfce as a remedy), primitive OSD.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Cinnamon, Unity, Conclusion<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->I gave a short try to cinnamon as well, in hopes that it was more stable than gnome shell. In short, it was not. It&rsquo;s certainly less of a memory hog, but I had some strange behavior with an additional phantom panel sometimes appearing at the bottom at the screen. And overall it looks a lot less polished.<!-- raw HTML omitted --><!-- raw HTML omitted -->Unity is more interesting, but it&rsquo;s too Ubuntu centric, I don&rsquo;t like the start button equivalent (slow, badly presented, don&rsquo;t care about HUD), the windows overview is not as useful as Gnome shell, the dock, something I usually like, is strangely annoying.<!-- raw HTML omitted --><!-- raw HTML omitted -->This is a very subjective review, my feeling is that in 2014, people should not waste their time with KDE or Cinnamon. Gnome shell could be worth a try if you don&rsquo;t care so much about memory leaks and slight instability but value a distraction free desktop. Otherwise go for XFCE or Unity on (X)ubuntu.</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/two-sabr-for-the-same-smile/">Two SABR for the same smile</a>
  </h1>
  <time datetime="2014-05-20T12:08:00Z" class="post-date">Tue, May 20, 2014</time>
  <p>While playing around with <!-- raw HTML omitted -->differential evolution<!-- raw HTML omitted --> &amp; SABR calibration, I noticed that sometimes, several set of parameters can lead to a very similar smile, usually the good one is for relatively low vol of vol and the bad one is for relatively high vol of vol. I first looked for errors in my implementation, but it&rsquo;s a real phenomenon.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->I used the normal implied volatility formula with beta=1, then converted it to lognormal (Black) volatility. While it might not be a great idea to rely on the normal formula with beta=1, I noticed the same phenomenon with the <!-- raw HTML omitted -->arbitrage free PDE density approach<!-- raw HTML omitted -->, especially for long maturities. Interestingly, I did not notice such behavior before with other stochastic volatility models like Heston or Schobel-Zhu: I suspect it has to do with the approximations rather than with the true behavior of SABR.<!-- raw HTML omitted --><!-- raw HTML omitted -->Differential evolution is surprisingly good at finding the global minimum without much initial knowledge, however when there are close fits like this it can be more problematic, usually this requires pushing the population size up. I find that differential evolution is a neat way to test the robustness (as well as performance) of different SABR algorithms as it will try many crazy sets.<!-- raw HTML omitted --><!-- raw HTML omitted -->In practice, for real world calibration, there is not much use of differential evolution to calibrate SABR as it is relatively simple to find a good initial guess.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/heston-vs-sabr-slice-by-slice-fit/">Heston vs SABR slice by slice fit</a>
  </h1>
  <time datetime="2014-05-15T22:06:00Z" class="post-date">Thu, May 15, 2014</time>
  <p>Some people use <!-- raw HTML omitted -->Heston to fit one slice <!-- raw HTML omitted -->of a volatility surface. In this case, some parameters are clearly redundant. Still, I was wondering how it fared against SABR, which is always used to fit a slice. And what about Schobel-Zhu?<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Aggregated error in fit per slice on 10 surfaces<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->With Heston, the calibration is actually slightly better with kappa=0, that is, without mean reversion, because the global optimization is easier and the mean reversion is fully redundant. It&rsquo;s still quite remarkable that 3 parameters result in a fit as good as 5 parameters.<!-- raw HTML omitted -->This is however not the case for Schobel-Zhu, where each &ldquo;redundant parameter&rdquo; seem to make a slight difference in the quality of calibration. kappa = 0 deteriorate a little bit the fit (the mean error is clearly higher), and theta near 0 (so calibrating 4 parameters) is also a little worse (although better than kappa = 0). Also interestingly, the five parameters Schobel-Zhu fit is slightly better than Heston, but not so when one reduce the number of free parameters.<!-- raw HTML omitted --><!-- raw HTML omitted -->So what about Heston vs SABR. It is interesting to consider the case of general Beta and Beta=1: it turns out that as confirmed for equities, beta=1 is actually a better choice.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Aggregated error in fit per slice on 10 surfaces<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Overall on my 10 surfaces composed each of around 10 slices, an admittedly small sample, Heston (without mean-reversion) fit is a little bit better than SABR. Also the <!-- raw HTML omitted -->SVI-SABR<!-- raw HTML omitted --> idea from Gatheral is not great: the fit is clearly worse than SABR with Beta=1 and even worse than a simple quadratic.<!-- raw HTML omitted -->Of course the best overall fit is achieved with the classic SVI, because it has 6 parameters while the others have only 3.<!-- raw HTML omitted --><!-- raw HTML omitted -->All the calibrations so far were done slice by slice independently, using levenberg marquardt on an initial guess found by differential evolution. Some people advocate for speed or stability of parameters reasons the idea of calibrating each slice using the previous slice as initial guess with a local optimizer like levenberg marquardt, in a bootstrapping fashion.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->The results can be quite different, especially for SVI, which then becomes the worst, even worse than SVI-SABR, which is actually a subset of SVI with fewer parameters. How can this be? <!-- raw HTML omitted --><!-- raw HTML omitted -->This is because as the number of parameters increases, the first slices optimizations have a disproportionate influence, and finding the real minimum is much more difficult, even with differential evolution for the first slice. It&rsquo;s easy to picture that you&rsquo;ll have much more chances to get stuck in some local minimum.<!-- raw HTML omitted -->It&rsquo;s interesting to note that the real stochastic volatility models are actually better behaved in this regard, but I am not so sure that this kind of calibration is such a great idea in general.<!-- raw HTML omitted --><!-- raw HTML omitted -->In practice, the SVI parameters fitted independently evolve in a given surface on each slice in a smooth manner, mostly monotonically. It&rsquo;s just that to go from one set on one slice to the other on the next slice, you might have to do something more than a local optimization.</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/quadratic-spline-with-knots-at-mid-points/">Quadratic Spline with Knots at Mid-Points</a>
  </h1>
  <time datetime="2014-05-14T14:12:00Z" class="post-date">Wed, May 14, 2014</time>
  <p>Two months ago, I looked at <!-- raw HTML omitted -->arbitrage free interpolation using piecewise-constant density<!-- raw HTML omitted -->. This is equivalent to a piecewise quadratic polynomial in call prices where each piece is centered around each call strike.<!-- raw HTML omitted --><!-- raw HTML omitted -->I wondered at the time what a quadratic spline would look like on this problem, as it should be very close in theory, except that we can ensure that it is C1, a condition for a good looking implied volatility.<!-- raw HTML omitted --><!-- raw HTML omitted -->For a while, I did not find any references around splines where knots are in between two interpolation points and derived my own formula. And then I lost the paper, but out of curiosity, I looked at the excellent De Boor book &ldquo;<!-- raw HTML omitted -->A Practical Guide to Splines<!-- raw HTML omitted -->&rdquo; and found that there was actually a chapter around this: quadratic splines with knots at mid-points. Interestingly, it turns out that a quadratic spline on standard knots is not always well defined, which is why, if one does quadratic splines, the knots need to be moved.<!-- raw HTML omitted --><!-- raw HTML omitted -->The papers from this era are quite rudimentary in their presentation (the book is much better). I found the paper from Demko 1977 &ldquo;<!-- raw HTML omitted -->Interpolation by Quadratic Splines<!-- raw HTML omitted -->&rdquo; quite usable for coding. I adjusted the boundaries to make the first and last quadratic fit the first two/last two strikes (adding a first strike at 0 and a large last strike if necessary) and spend countless time worrying about indices. The result on a simple classic example is interesting.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->On the non monotonic discrete density data of my earlier blog entry, this gives:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->QSpline is the quadratic spline<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Unfortunately, interpolating small prices with such a spline results in a highly oscillating interpolation: this is the <!-- raw HTML omitted -->Gibbs phenomenon for splines<!-- raw HTML omitted -->. We need to loose strict C1 continuity for practical applications, and use a first derivative approximation instead, very much like the Harmonic cubic spline.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->On Jaeckel data, the quadratic spline on prices is highly oscillating<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>

  
</article>
</div>
<p style="text-align:left; width:49%; display: inline-block;"><a href="/page/9/">Previous</a></p>
<p style="text-align:right; width:50%;  display: inline-block;"><a href="/page/11/">Next</a></p>
    </main>

    
      
    
  </body>
</html>
