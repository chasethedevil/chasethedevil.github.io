<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.83.1" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Chase the Devil</title>
  <meta name="description" content="A personal, independent, technical blog" />

  
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://chasethedevil.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">
<link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&display=swap" rel="stylesheet">
 <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://chasethedevil.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Chase the Devil" />
  <script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://chasethedevil.github.io/"><h1 style="font-family: 'UnifrakturMaguntia', cursive;font-weight: normal;">Chase the Devil</h1></a>
      <p class="lead">
       A personal, independent, technical blog 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://chasethedevil.github.io/">Blog</a> </li>
        <li><a href="/about/"> About </a></li><li><a href="/post/"> Posts </a></li>
      </ul>

        <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <script type="text/javascript">document.write("<a href=\"mail" + "to:" + new Array("fabien","2ipi.com").join("@") + "?subject=your%20blog\">" + '<i class="fa fa-envelope fa-3x"></i>' + "</" + "a>");</script>
      
      
      
      
      
      
      <a href="https://twitter.com/logos01"><i class="fa fa-twitter-square fa-3x"></i></a>
      
      <a href="https://chasethedevil.github.io/index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-3x"></i></a>
      </li>
    </ul>
 </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/cholesky-jakarta-commons-math/">Cholesky &amp; Jakarta Commons Math</a>
  </h1>
  <time datetime="2009-05-15T19:01:00Z" class="post-date">Fri, May 15, 2009</time>
  <p>In Finance, <!-- raw HTML omitted -->Cholesky<!-- raw HTML omitted --> is a useful way to decompose Matrix. It is not so simple to find a BSD licensed code using cholesky (most of them are GPL like <!-- raw HTML omitted -->this one<!-- raw HTML omitted -->). There is <!-- raw HTML omitted -->one<!-- raw HTML omitted --> in <!-- raw HTML omitted -->Apache Commons Maths<!-- raw HTML omitted --> library, which is a very interesting library. However for performance, it is still not very practical for some things like Cholesky.<!-- raw HTML omitted --><!-- raw HTML omitted -->Looking at the source one can easily understand why. I did a small (many people will say not representative 1 million loop test) and finds out:<!-- raw HTML omitted -->cholesky GPL= 5.4ms<!-- raw HTML omitted -->cholesky BSD=37.1ms<!-- raw HTML omitted --><!-- raw HTML omitted -->So BSD code is 7 times slower! Of course it can do a bit more and has many checks of validity, but still. It shows it is not easy to do Math libraries, because some people will care a lot about this performance difference, and some other people won&rsquo;t but will like the other &ldquo;features&rdquo;.</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/hull-american-option-price-fallacies/">Hull American Option Price Fallacies</a>
  </h1>
  <time datetime="2009-05-15T16:01:00Z" class="post-date">Fri, May 15, 2009</time>
  <p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Hull says American put is best exercised immediately and american call is optimal at expiry like a european. Is this really true?<!-- raw HTML omitted --><!-- raw HTML omitted -->At first it seems really clever and model show clearly this. But if we change the market assumptions only a tiny bit, everything falls down.<!-- raw HTML omitted --><!-- raw HTML omitted -->I could not detail everything in a blog post so I created a <!-- raw HTML omitted -->static web page about it<!-- raw HTML omitted -->. Everything was produced in Java using algorithm found in popular books and graphs through JFreeChart.</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/on-quasi-random-numbers-mersennetwister-vs-sobol-precision-in-asian-option-pricing/">On Quasi Random Numbers - MersenneTwister vs Sobol precision in Asian Option Pricing</a>
  </h1>
  <time datetime="2009-05-05T15:02:00Z" class="post-date">Tue, May 5, 2009</time>
  <p>While starting a side project that does Monte Carlo pricing in Java (<!-- raw HTML omitted --><a href="http://code.google.com/p/javamc/">http://code.google.com/p/javamc/</a><!-- raw HTML omitted --> - nothing yet there I am waiting for Mercurial repository support), I wondered what was the importance of quasi random numbers versus more regular pseudo random numbers in Monte Carlo simulations.<!-- raw HTML omitted --><!-- raw HTML omitted -->This brought me to read more carefully several books about Monte Carlo and Finance (<!-- raw HTML omitted -->Haug Option Pricing<!-- raw HTML omitted -->, <!-- raw HTML omitted -->Sobol Primer on Monte Carlo<!-- raw HTML omitted -->, and <!-- raw HTML omitted -->Glasserman Monte Carlo Methods in Finance Engineering<!-- raw HTML omitted -->). I had quite a hard time to understand why the dimension of the quasi random generator was so important to price an asian option. Intuitively I thought the averaging points of an asian option were all on the same path, so they should be using the same random generator. This is very wrong as one does not care about the path in the first place but just in simulating each point in the average (using the regular black and scholes hypothesis). Finding the estimation for the average on the given points forces to use independent random generators for each point, because we want to approximate the estimation by the sum over those random points for each point.<!-- raw HTML omitted --><!-- raw HTML omitted -->There is another simple argument to explain why independence of the random generators is so important. If we use the same generator for each point, then each point will move exactly the same way at each simulation. The average of those point will therefore behave exactly the same way as if there was only 1 point using the same generator. And we don&rsquo;t price an asian anymore but just a regular vanilla option.<!-- raw HTML omitted --><!-- raw HTML omitted -->Using a pseudo random generator, one does not see the problem of dimension, because we can create N independent dimensions by just taking numbers N by N on a pseudo random generator. So effectively having 1 or N dimensions is the same on a pseudo random generator.<!-- raw HTML omitted --><!-- raw HTML omitted -->Still I wrote a small test to see if a 1D quasi random generator was so bad when simulating N dimensions (taking values N by N on the quasi random generator). Here are the results:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->MersenneTwister vs MersenneTwister on 10D asian:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:43:51,111  INFO MonteCarloSimulationTest:114 - 867970000 &ndash; expPrice=0.978958644504466<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:43:51,428  INFO MonteCarloSimulationTest:120 - 314619000 &ndash; expPrice=0.9733220318545934<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:43:51,430  INFO MonteCarloSimulationTest:122 - relative difference=-0.005757763804951897<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->can be as high as 2%<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Sobol vs MersenneTwister on 10D asian:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:48:46,909  INFO MonteCarloSimulationTest:115 - 980209000 &ndash; expPrice=0.9895032774079221<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:48:47,345  INFO MonteCarloSimulationTest:121 - 433685000 &ndash; expPrice=0.9790264042895171<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:48:47,348  INFO MonteCarloSimulationTest:123 - relative difference=-0.010588012548932534<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->about 1% it is actually bounded by MersenneTwister precision.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Sobol vs Sobol1D on 10D asian:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:47:08,614  INFO MonteCarloSimulationTest:115 - 717444000 &ndash; expPrice=0.8810736428068913<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:47:08,925  INFO MonteCarloSimulationTest:121 - 308499000 &ndash; expPrice=0.9791449305055208<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->14:47:08,927  INFO MonteCarloSimulationTest:123 - relative difference=0.11130884290920073<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->about 10% and stays that way even when increasing number of simulations.<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Using an asian rate with 10 points, we see that Sobol1D will always give a very bad estimate, no matter the number of simulations. While Sobol used properly will give (much) better precision for less iterations. So even though there is the word random in quasi random, the numbers are very far from being random or even behaving like random numbers. It helped me to read about Van der Corput and Halton numbers to really understand quasi random numbers.</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/java-logging-still-crap-in-2009/">Java Logging Still Crap in 2009</a>
  </h1>
  <time datetime="2009-04-24T15:01:00Z" class="post-date">Fri, Apr 24, 2009</time>
  <p>When java logging API was first introduced in JDK 1.4 in 2002, it caused quite a lot a fuss around, with everybody asking &ldquo;Why did not they just include Log4j instead of creating their own bastard child?&rdquo;.<!-- raw HTML omitted --><!-- raw HTML omitted -->I remember having looked at it very shortly before continuing using Log4j on all projects I have been involved with.<!-- raw HTML omitted --><!-- raw HTML omitted -->Today, while doing a very small project, I tried once more to use <!-- raw HTML omitted -->java logging<!-- raw HTML omitted -->. The main reason is that I was lazy to add a dependency to one more jar for this small project. While trying I found out that:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --> you still need to use a damned JVM parameter to point to your configuration file<!-- raw HTML omitted --><!-- raw HTML omitted -->you can not change the formatting without writing a formatter class!<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->It&rsquo;s 2009! What has Sun done? I am amazed the most elementary things you expect from a Logger are still not included by default in the JDK.</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/bachelier-vs.-black/">Bachelier vs. Black</a>
  </h1>
  <time datetime="2009-03-23T17:58:00Z" class="post-date">Mon, Mar 23, 2009</time>
   

<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_9RyqGT46Fbk/ScfCRxmTocI/AAAAAAAACzk/5_lPpPc7LzU/s1600-h/bachelier_vs_black_normal.png"><img style="margin: 0pt 10px 10px 0pt; float: left; cursor: pointer; width: 400px; height: 300px;" src="http://4.bp.blogspot.com/_9RyqGT46Fbk/ScfCRxmTocI/AAAAAAAACzk/5_lPpPc7LzU/s400/bachelier_vs_black_normal.png" alt="" id="BLOGGER_PHOTO_ID_5316431495761732034" border="0" /></a><br />Black and Scholes gives a strange result for the price of a binary option under high volatility.  You will learn here how to simulate a stock price evolution using Java, and how to show it using JFreeChart library. It starts with more complex concepts (don't be afraid) and goes done towards simpler things.<br /><br />I could not write all that in a blog format, so I created a old HTML page about it <a href="http://31416.appspot.com/static/bachblack/Bachelier_vs_Black.html">here</a> and a <a href="http://31416.appspot.com/static/bachblack/Bachelier_vs_Black.pdf">PDF version</a>.<br /><span style="text-decoration: underline;"></span>



  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/linux-audio-state-miserable/">Linux Audio State = Miserable</a>
  </h1>
  <time datetime="2009-03-19T12:39:00Z" class="post-date">Thu, Mar 19, 2009</time>
  <p>There are lots of programs for playing MP3 under linux, a few dealing decently with big libraries. But when you start looking for a program that does crossfade well and manage big libraries easily - there is nothing.<!-- raw HTML omitted -->Rhythmbox does some crossfade, but crashes when you move manually in the song. Audacious does some crossfade but regularly crashes with crossfade plugin.<!-- raw HTML omitted --><!-- raw HTML omitted -->The real alternative are AIMP2 or Foobar2000 in Wine. It is quite incredible that you can have good solid crossfade in wine and not natively in Linux.<!-- raw HTML omitted --><!-- raw HTML omitted -->Maybe people spent too much time on useless Pulseaudio (I have much less issues using only ALSA).</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/senior-developers-team-productivity-x4-from-ms-research-paper/">Senior Developers Team Productivity X4 (from MS Research Paper)</a>
  </h1>
  <time datetime="2009-02-10T10:44:00Z" class="post-date">Tue, Feb 10, 2009</time>
  <p>There is a very interesting <!-- raw HTML omitted -->MS Research paper about test driven development<!-- raw HTML omitted --> (TDD). It is one of the only real study about it that I know of. The paper conclusions from experiments over 4 TDD teams vs 4 traditional teams is:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->&ldquo;TDD seems to be applicable in various domains and can significantly reduce the defect density of developed software without significant productivity reduction of the development team&rdquo;<!-- raw HTML omitted --><!-- raw HTML omitted -->Their data gives also other interesting results:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->An experienced team (5 people over 10 years + 2 people under 5 years) : 155KLOC C# code (+60 test).<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->A junior team (3 people under 10 years + 6 people under 5 years): 41 KLOC Java code (+28 test).<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->If you do the ratio of KLOC/man month, you have the following graph:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->I know this is very far from scientific evidence and more like astrology, but still, the most conservative ratio for senior/junior is <!-- raw HTML omitted -->4.23<!-- raw HTML omitted -->!</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/the-end-of-rings-around-plain-java-a-better-concurrency-test/">The End Of Rings Around Plain Java - A Better Concurrency Test</a>
  </h1>
  <time datetime="2009-01-15T15:54:00Z" class="post-date">Thu, Jan 15, 2009</time>
  <p>In my <!-- raw HTML omitted -->previous post<!-- raw HTML omitted -->, I was wondering why single thread was faster. D Andreou gave the correct explanation: as we send only 1 start message and as each node only send 1 message to the next one, there is always only 1 message being processed. So the test is optimum on 1 thread. It does not make much sense to make a multithreading benchmark on a problem that is fundamentally single threaded.<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted -->His suggestion was to simple send N start messages where N &gt;= number of processors. In theory, the performance will become optimal with N threads then. Unfortunately this is not what happened in real life. In real life the single threaded performance is still better if you send even 16 messages on a biprocessor machine.  <!-- raw HTML omitted --> <!-- raw HTML omitted -->     <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->static<!-- raw HTML omitted --> <!-- raw HTML omitted -->void<!-- raw HTML omitted --> main(String[] args) <!-- raw HTML omitted -->throws<!-- raw HTML omitted --> Exception {<!-- raw HTML omitted -->         OptimizedRing ring = <!-- raw HTML omitted -->new<!-- raw HTML omitted --> OptimizedRing();<!-- raw HTML omitted -->         RingNode node = ring.startRing(Integer.parseInt(args[<!-- raw HTML omitted -->0<!-- raw HTML omitted -->]));<!-- raw HTML omitted -->         node.sendMessage(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> StartMessage());<!-- raw HTML omitted -->         node.sendMessage(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> TokenMessage(node.nodeId,<!-- raw HTML omitted -->1<!-- raw HTML omitted -->));<!-- raw HTML omitted -->         node.sendMessage(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> TokenMessage(node.nodeId,<!-- raw HTML omitted -->1<!-- raw HTML omitted -->));<!-- raw HTML omitted -->         node.sendMessage(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> TokenMessage(node.nodeId,<!-- raw HTML omitted -->1<!-- raw HTML omitted -->));<!-- raw HTML omitted -->         ring.executor.awaitTermination(<!-- raw HTML omitted -->10<!-- raw HTML omitted -->, TimeUnit.MINUTES);<!-- raw HTML omitted -->     }<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->My idea was that it was related to the swiching from thread to thread overhead, which is precisely what I think the original author of the test had in mind to test. I am not 100% convinced it is really what&rsquo;s happening. I wanted a test that would actually be faster using N threads; so I decided to add a bit of computation at before processing each Token. Unfortunately I had the bad idea to compute Pi by Monte Carlo method to do that. Running my tests I was surprised it did not change the results, and made things worse the most computer intensive the computation was (increasing the number of monte carlo iterations). It scared me a bit wondering what the hell could be wrong there. The following class performs much worse with 2 threads compared to 1:<!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->class<!-- raw HTML omitted --> BadParallelPi {<!-- raw HTML omitted --> <!-- raw HTML omitted -->     <!-- raw HTML omitted -->private<!-- raw HTML omitted --> <!-- raw HTML omitted -->static<!-- raw HTML omitted --> <!-- raw HTML omitted -->void<!-- raw HTML omitted --> startExecutors() <!-- raw HTML omitted -->throws<!-- raw HTML omitted --> Exception {        <!-- raw HTML omitted -->         <!-- raw HTML omitted -->long<!-- raw HTML omitted --> startTime = System.currentTimeMillis();<!-- raw HTML omitted -->         System.out.println(startTime);<!-- raw HTML omitted -->         ExecutorService executor1 = Executors.newFixedThreadPool(<!-- raw HTML omitted -->1<!-- raw HTML omitted -->);<!-- raw HTML omitted -->         executor1.execute(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> Computation());<!-- raw HTML omitted -->         executor1.execute(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> Computation());<!-- raw HTML omitted -->         executor1.shutdown();<!-- raw HTML omitted -->         executor1.awaitTermination(<!-- raw HTML omitted -->60<!-- raw HTML omitted -->, TimeUnit.SECONDS);<!-- raw HTML omitted -->         <!-- raw HTML omitted -->long<!-- raw HTML omitted --> delay = System.currentTimeMillis() - startTime;<!-- raw HTML omitted -->         System.out.println(<!-- raw HTML omitted -->&quot;finished single thread in &quot;<!-- raw HTML omitted -->+(delay/<!-- raw HTML omitted -->1000.0<!-- raw HTML omitted -->));<!-- raw HTML omitted -->         startTime = System.currentTimeMillis();<!-- raw HTML omitted -->         System.out.println(startTime);<!-- raw HTML omitted -->         executor1 = Executors.newFixedThreadPool(<!-- raw HTML omitted -->2<!-- raw HTML omitted -->);<!-- raw HTML omitted -->         executor1.execute(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> Computation());<!-- raw HTML omitted -->         executor1.execute(<!-- raw HTML omitted -->new<!-- raw HTML omitted --> Computation());<!-- raw HTML omitted -->         executor1.shutdown();<!-- raw HTML omitted -->         executor1.awaitTermination(<!-- raw HTML omitted -->60<!-- raw HTML omitted -->, TimeUnit.SECONDS);<!-- raw HTML omitted -->         delay = System.currentTimeMillis() - startTime;<!-- raw HTML omitted -->         System.out.println(<!-- raw HTML omitted -->&quot;finished 2 threads in &quot;<!-- raw HTML omitted -->+(delay/<!-- raw HTML omitted -->1000.0<!-- raw HTML omitted -->)); <!-- raw HTML omitted -->     }<!-- raw HTML omitted -->     <!-- raw HTML omitted -->     <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->static<!-- raw HTML omitted --> <!-- raw HTML omitted -->class<!-- raw HTML omitted --> Computation <!-- raw HTML omitted -->implements<!-- raw HTML omitted --> Runnable {<!-- raw HTML omitted -->         <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->volatile<!-- raw HTML omitted --> <!-- raw HTML omitted -->int<!-- raw HTML omitted --> count = <!-- raw HTML omitted -->0<!-- raw HTML omitted -->;<!-- raw HTML omitted -->          <!-- raw HTML omitted -->private<!-- raw HTML omitted --> <!-- raw HTML omitted -->double<!-- raw HTML omitted --> computePi() {<!-- raw HTML omitted -->             <!-- raw HTML omitted -->double<!-- raw HTML omitted --> pi = <!-- raw HTML omitted -->0<!-- raw HTML omitted -->;<!-- raw HTML omitted -->             <!-- raw HTML omitted -->double<!-- raw HTML omitted --> x,y;<!-- raw HTML omitted -->             <!-- raw HTML omitted -->int<!-- raw HTML omitted --> n = <!-- raw HTML omitted -->10000000<!-- raw HTML omitted -->;<!-- raw HTML omitted -->             <!-- raw HTML omitted -->for<!-- raw HTML omitted --> (<!-- raw HTML omitted -->int<!-- raw HTML omitted --> i=<!-- raw HTML omitted -->0<!-- raw HTML omitted -->;i&lt;n;i++) {<!-- raw HTML omitted -->                 x = Math.random();<!-- raw HTML omitted -->                 x *= x;<!-- raw HTML omitted -->                 y = Math.random();<!-- raw HTML omitted -->                 y *= y;<!-- raw HTML omitted -->                 <!-- raw HTML omitted -->if<!-- raw HTML omitted --> (x+y &lt; <!-- raw HTML omitted -->1<!-- raw HTML omitted -->) {<!-- raw HTML omitted -->                     pi +=<!-- raw HTML omitted -->1<!-- raw HTML omitted -->;<!-- raw HTML omitted -->                 }<!-- raw HTML omitted -->             }<!-- raw HTML omitted -->             pi = <!-- raw HTML omitted -->4<!-- raw HTML omitted -->*pi/n;<!-- raw HTML omitted -->             <!-- raw HTML omitted -->return<!-- raw HTML omitted --> pi;<!-- raw HTML omitted -->         }<!-- raw HTML omitted -->         <!-- raw HTML omitted -->         <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->void<!-- raw HTML omitted --> run() {<!-- raw HTML omitted -->             <!-- raw HTML omitted -->double<!-- raw HTML omitted --> pi = computePi();<!-- raw HTML omitted -->             <!-- raw HTML omitted -->long<!-- raw HTML omitted --> time = System.currentTimeMillis();<!-- raw HTML omitted -->             System.out.println(time+<!-- raw HTML omitted -->&quot; thread &quot;<!-- raw HTML omitted -->+Thread.currentThread().getId()+<!-- raw HTML omitted -->&quot; pi=&quot;<!-- raw HTML omitted -->+pi);<!-- raw HTML omitted -->             count++;<!-- raw HTML omitted -->         }        <!-- raw HTML omitted -->     }<!-- raw HTML omitted --> <!-- raw HTML omitted -->     <!-- raw HTML omitted -->     <!-- raw HTML omitted -->public<!-- raw HTML omitted --> <!-- raw HTML omitted -->static<!-- raw HTML omitted --> <!-- raw HTML omitted -->void<!-- raw HTML omitted --> main(String[] args) <!-- raw HTML omitted -->throws<!-- raw HTML omitted --> Exception {<!-- raw HTML omitted -->         startExecutors();<!-- raw HTML omitted -->     }<!-- raw HTML omitted --> } <!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->Did you figure out why?<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted -->It took me less time with this simple code than with the original ring test to find out why. It is simply because of the Math.random call. Math.random only creates one random number generator, and it will be shared among threads. So every thread will wait at the other one at this point. Creating one random generator per thread showed 2 threads were much faster than 1, finally.<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted -->Back to the original ring test. Adding the correct way to compute Pi by Monte Carlo, I now had decent test results as long as the number of iterations is not too small. 10 iterations is enough to show a real difference between N threads and 1. Adding a small computation helps figuring out what happens behind the scene. You can also verify D Andreou claim, using only 1 start message the single threaded version is faster. If computation is too weak (for example number of Monte Carlo iteration of 0,  one only measures method calls between threads (context switching), which is obviously optimal for 1 thread. Measuring Actor libraries on it is dangerous: if I write a single threaded Actor library, it will be the fastest of this test, but it certainly is not what you want to use as Actor library.<!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->Let&rsquo;s see now how Scala fares compared to the Plain Java solution, using computation: <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Machine<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Algorithm<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Time for 100000 ring count, 10 mc, 4 messages<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Time for 10000 ring count, 100 mc, 4 messages<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 2 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->57s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->37s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 4 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->78s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->39s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Scala Actors<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->82s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->47s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->SimpleRing (100 Threads)<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->137s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->58s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Duo<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 1 Thread<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->89s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->71s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Quad<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 4 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->81s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->25s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Quad<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Scala Actors<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->71s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->30s<!-- raw HTML omitted --><!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Quad<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 2 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->61s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->43s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted -->  <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->Core2Quad<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->OptimizedRing 1 Threads<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->100s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->   <!-- raw HTML omitted -->    <!-- raw HTML omitted -->80s<!-- raw HTML omitted -->   <!-- raw HTML omitted -->  <!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted --> The Core2Duo is Intel(R) Core(TM)2 Duo CPU     T7250  @ 2.00GHz <!-- raw HTML omitted -->The Core2Quad is Intel(R) Core(TM)2 Quad CPU    Q6600  @ 2.40GHz <!-- raw HTML omitted --><!-- raw HTML omitted --> It is interesting to compare results of 4 threads on a biprocessor with monte carlo count of 10 and 100. We see a much higher thread overhead with fewer computation. With too few computation in monte carlo, the overhead of threads is too high over 2 concurrent threads. This explains why the very simple threading architecture fares much better in the last column compared to the previous one. <!-- raw HTML omitted --><!-- raw HTML omitted --> Scala Actors fares much better when it is not hindered in the creation of too many threads. It seem actually very good at abstracting multithreading intricacies, while still providing near Java performance in the real world where each actor does enough computation and multithreading is important.</p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/object-oriented-analysis-and-design-with-applications-book-review/">Object Oriented Analysis And Design with Applications Book Review</a>
  </h1>
  <time datetime="2009-01-08T17:24:00Z" class="post-date">Thu, Jan 8, 2009</time>
  <p>A while ago, I had a comment from someone implying I knew nothing about OO programming because I had not mentioned (and therefore read) <!-- raw HTML omitted -->Object Oriented Analysis And Design with Applications<!-- raw HTML omitted --> from G. Booch. I was intrigued by such a silly comment and decided to look at this book that was considered as the bible of OOP. <!-- raw HTML omitted --> <!-- raw HTML omitted -->Well, I don't find it that good! But I don't find the bible particularly good either. I like <!-- raw HTML omitted -->B Meyer Object Oriented Software Construction<!-- raw HTML omitted --> book much more, because it is more practical, more in touch with realities while pointing at the real important problems like: &quot;<!-- raw HTML omitted -->Real systems have no top<!-- raw HTML omitted -->&quot;<!-- raw HTML omitted --> <!-- raw HTML omitted -->In contrast G Booch book has too much evident concepts that don't really make you learn anything or think things a different way. It is a good book for someone who is learning OO for the first time. It covers the subject in details, but I did not find anything in it that made me say &quot;wow!&quot;. It is like most other book you can find on OO. Furthermore only the first parts are on OO, the rest is more a UML tutorial.<!-- raw HTML omitted --> <!-- raw HTML omitted --></p>

  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://chasethedevil.github.io/post/running-rings-around-plain-java-the-killer-code/">Running Rings Around Plain Java - The Killer Code</a>
  </h1>
  <time datetime="2009-01-08T13:21:00Z" class="post-date">Thu, Jan 8, 2009</time>
  <p>I wrote my <!-- raw HTML omitted -->previous<!-- raw HTML omitted --> post too fast. I found a very simple change that increases the speed x6!<!-- raw HTML omitted --><!-- raw HTML omitted -->The idea is too process messages in a ThreadPoolExecutor. As my Nodes are Runnable, I just needed to initialize a common ThreadPoolExecutor, and in a sendMessage, execute the runnable each time.<!-- raw HTML omitted --><!-- raw HTML omitted -->Here is the full code:<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->class<!-- raw HTML omitted --><!-- raw HTML omitted --> OptimizedRing {<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> ExecutorService executor;<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->static<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->void<!-- raw HTML omitted --><!-- raw HTML omitted --> main(String[] args) <!-- raw HTML omitted --><!-- raw HTML omitted -->throws<!-- raw HTML omitted --><!-- raw HTML omitted --> Exception {<!-- raw HTML omitted -->        OptimizedRing ring = <!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> OptimizedRing();<!-- raw HTML omitted -->        RingNode node = ring.startRing(Integer.parseInt(args[<!-- raw HTML omitted --><!-- raw HTML omitted -->0<!-- raw HTML omitted --><!-- raw HTML omitted -->]));<!-- raw HTML omitted -->        node.sendMessage(<!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> StartMessage());<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> RingNode startRing(<!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> n) {<!-- raw HTML omitted -->        RingNode[] nodes = spawnNodes(n, startTimer());<!-- raw HTML omitted -->        connectNodes(n, nodes);<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->return<!-- raw HTML omitted --><!-- raw HTML omitted --> nodes[<!-- raw HTML omitted --><!-- raw HTML omitted -->0<!-- raw HTML omitted --><!-- raw HTML omitted -->];<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> Timer startTimer() {<!-- raw HTML omitted -->        Timer timer = <!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> Timer();<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> Thread(timer).start();<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->return<!-- raw HTML omitted --><!-- raw HTML omitted --> timer;<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> RingNode[] spawnNodes(<!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> n, <!-- raw HTML omitted --><!-- raw HTML omitted -->final<!-- raw HTML omitted --><!-- raw HTML omitted --> Timer timer) {<!-- raw HTML omitted -->        System.out.println(<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;constructing nodes&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->long<!-- raw HTML omitted --><!-- raw HTML omitted --> start = System.currentTimeMillis();<!-- raw HTML omitted -->        executor = Executors.newFixedThreadPool(<!-- raw HTML omitted --><!-- raw HTML omitted -->4<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->        RingNode[] nodes = <!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> RingNode[n+<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->];<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->for<!-- raw HTML omitted --><!-- raw HTML omitted --> (<!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> i = <!-- raw HTML omitted --><!-- raw HTML omitted -->0<!-- raw HTML omitted --><!-- raw HTML omitted -->; i &lt; n ; i++) {<!-- raw HTML omitted -->            nodes[i] = <!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> RingNode(i, timer, <!-- raw HTML omitted --><!-- raw HTML omitted -->null<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->        }<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->long<!-- raw HTML omitted --><!-- raw HTML omitted --> end = System.currentTimeMillis();<!-- raw HTML omitted -->        System.out.println(<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;Took &quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->+(end-start)+<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;ms to construct &quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->+n+<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot; nodes&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->return<!-- raw HTML omitted --><!-- raw HTML omitted --> nodes;<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->void<!-- raw HTML omitted --><!-- raw HTML omitted --> connectNodes(<!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> n, RingNode[] nodes) {<!-- raw HTML omitted -->        System.out.println(<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;connecting nodes&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->        nodes[n] = nodes[<!-- raw HTML omitted --><!-- raw HTML omitted -->0<!-- raw HTML omitted --><!-- raw HTML omitted -->];<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->for<!-- raw HTML omitted --><!-- raw HTML omitted --> (<!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> i=<!-- raw HTML omitted --><!-- raw HTML omitted -->0<!-- raw HTML omitted --><!-- raw HTML omitted -->; i&lt;n; i++) {<!-- raw HTML omitted -->            nodes[i].connect(nodes[i+<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->]);<!-- raw HTML omitted -->        }<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->interface<!-- raw HTML omitted --><!-- raw HTML omitted --> Message {<!-- raw HTML omitted -->        String getType();<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->static<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->class<!-- raw HTML omitted --><!-- raw HTML omitted --> StartMessage <!-- raw HTML omitted --><!-- raw HTML omitted -->implements<!-- raw HTML omitted --><!-- raw HTML omitted --> Message {<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> String getType() {<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->return<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;START&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->        }<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->static<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->class<!-- raw HTML omitted --><!-- raw HTML omitted --> StopMessage <!-- raw HTML omitted --><!-- raw HTML omitted -->implements<!-- raw HTML omitted --><!-- raw HTML omitted --> Message {<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> String getType() {<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->return<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;STOP&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->;            <!-- raw HTML omitted -->        }<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->static<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->class<!-- raw HTML omitted --><!-- raw HTML omitted --> CancelMessage <!-- raw HTML omitted --><!-- raw HTML omitted -->implements<!-- raw HTML omitted --><!-- raw HTML omitted --> Message {<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> String getType() {<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->return<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;CANCEL&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->        }<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->static<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->class<!-- raw HTML omitted --><!-- raw HTML omitted --> TokenMessage <!-- raw HTML omitted --><!-- raw HTML omitted -->implements<!-- raw HTML omitted --><!-- raw HTML omitted --> Message {<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> nodeId;<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> value;<!-- raw HTML omitted --><!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> TokenMessage(<!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> nodeId, <!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> value) {<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->this<!-- raw HTML omitted --><!-- raw HTML omitted -->.nodeId = nodeId;<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->this<!-- raw HTML omitted --><!-- raw HTML omitted -->.value = value;<!-- raw HTML omitted -->        }<!-- raw HTML omitted --><!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> String getType() {<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->return<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;TOKEN&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->        }<!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->class<!-- raw HTML omitted --><!-- raw HTML omitted --> RingNode <!-- raw HTML omitted --><!-- raw HTML omitted -->implements<!-- raw HTML omitted --><!-- raw HTML omitted --> Runnable {<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> nodeId;<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> Timer timer;<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> RingNode nextNode;<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> BlockingQueue&lt;Message&gt; queue = <!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> LinkedBlockingQueue&lt;Message&gt;();<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->boolean<!-- raw HTML omitted --><!-- raw HTML omitted --> isActive = <!-- raw HTML omitted --><!-- raw HTML omitted -->false<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->        <!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> RingNode(<!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> id, Timer timer, RingNode nextNode) {<!-- raw HTML omitted -->            nodeId = id;<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->this<!-- raw HTML omitted --><!-- raw HTML omitted -->.timer = timer;<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->this<!-- raw HTML omitted --><!-- raw HTML omitted -->.nextNode = nextNode;                        <!-- raw HTML omitted -->        }<!-- raw HTML omitted --><!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->void<!-- raw HTML omitted --><!-- raw HTML omitted --> connect(RingNode node) {<!-- raw HTML omitted -->            nextNode = node;<!-- raw HTML omitted -->            isActive = <!-- raw HTML omitted --><!-- raw HTML omitted -->true<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->        }<!-- raw HTML omitted --><!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->void<!-- raw HTML omitted --><!-- raw HTML omitted --> sendMessage(Message m) {<!-- raw HTML omitted -->            queue.add(m);<!-- raw HTML omitted -->            executor.execute(<!-- raw HTML omitted --><!-- raw HTML omitted -->this<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->        }<!-- raw HTML omitted --><!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->void<!-- raw HTML omitted --><!-- raw HTML omitted --> run() {<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (isActive) {<!-- raw HTML omitted -->                <!-- raw HTML omitted --><!-- raw HTML omitted -->try<!-- raw HTML omitted --><!-- raw HTML omitted --> {<!-- raw HTML omitted -->                    Message m = queue.take();<!-- raw HTML omitted -->                    <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (m <!-- raw HTML omitted --><!-- raw HTML omitted -->instanceof<!-- raw HTML omitted --><!-- raw HTML omitted --> StartMessage) {<!-- raw HTML omitted -->                        log(<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;Starting messages&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->                        timer.sendMessage(m);<!-- raw HTML omitted -->                        nextNode.sendMessage(<!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> TokenMessage(nodeId, <!-- raw HTML omitted --><!-- raw HTML omitted -->0<!-- raw HTML omitted --><!-- raw HTML omitted -->));<!-- raw HTML omitted -->                    } <!-- raw HTML omitted --><!-- raw HTML omitted -->else<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (m <!-- raw HTML omitted --><!-- raw HTML omitted -->instanceof<!-- raw HTML omitted --><!-- raw HTML omitted --> StopMessage) {<!-- raw HTML omitted -->                        log(<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;Stopping&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->                        nextNode.sendMessage(m);<!-- raw HTML omitted -->                        isActive = <!-- raw HTML omitted --><!-- raw HTML omitted -->false<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->                        <!-- raw HTML omitted -->//<!-- raw HTML omitted --><!-- raw HTML omitted -->                    } <!-- raw HTML omitted --><!-- raw HTML omitted -->else<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (m <!-- raw HTML omitted --><!-- raw HTML omitted -->instanceof<!-- raw HTML omitted --><!-- raw HTML omitted --> TokenMessage) {<!-- raw HTML omitted -->                        <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (((TokenMessage)m).nodeId == nodeId) {<!-- raw HTML omitted -->                            <!-- raw HTML omitted --><!-- raw HTML omitted -->int<!-- raw HTML omitted --><!-- raw HTML omitted --> nextValue = ((TokenMessage)m).value + <!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->                            <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (nextValue % <!-- raw HTML omitted --><!-- raw HTML omitted -->10000<!-- raw HTML omitted --><!-- raw HTML omitted --> == <!-- raw HTML omitted --><!-- raw HTML omitted -->0<!-- raw HTML omitted --><!-- raw HTML omitted -->) {<!-- raw HTML omitted -->                                log(<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;Around ring &quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->+nextValue+<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot; times&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->);<!-- raw HTML omitted -->                            }<!-- raw HTML omitted -->                            <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (nextValue == <!-- raw HTML omitted --><!-- raw HTML omitted -->1000000<!-- raw HTML omitted --><!-- raw HTML omitted -->) {<!-- raw HTML omitted -->                                timer.sendMessage(<!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> StopMessage());<!-- raw HTML omitted -->                                timer.sendMessage(<!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> CancelMessage());<!-- raw HTML omitted -->                                nextNode.sendMessage(<!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> StopMessage());<!-- raw HTML omitted -->                                isActive = <!-- raw HTML omitted --><!-- raw HTML omitted -->false<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->                            } <!-- raw HTML omitted --><!-- raw HTML omitted -->else<!-- raw HTML omitted --><!-- raw HTML omitted --> {<!-- raw HTML omitted -->                                nextNode.sendMessage(<!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> TokenMessage(nodeId, nextValue));<!-- raw HTML omitted -->                            }<!-- raw HTML omitted --><!-- raw HTML omitted -->                        } <!-- raw HTML omitted --><!-- raw HTML omitted -->else<!-- raw HTML omitted --><!-- raw HTML omitted --> {<!-- raw HTML omitted -->                            nextNode.sendMessage(m);<!-- raw HTML omitted -->                        }<!-- raw HTML omitted -->                    }<!-- raw HTML omitted --><!-- raw HTML omitted -->                } <!-- raw HTML omitted --><!-- raw HTML omitted -->catch<!-- raw HTML omitted --><!-- raw HTML omitted --> (InterruptedException ie) {<!-- raw HTML omitted -->                    ie.printStackTrace();<!-- raw HTML omitted -->                }<!-- raw HTML omitted -->            }<!-- raw HTML omitted -->        }<!-- raw HTML omitted --><!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->void<!-- raw HTML omitted --><!-- raw HTML omitted --> log(String s) {<!-- raw HTML omitted -->            System.out.println(System.currentTimeMillis()+<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot; &quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->+nodeId+<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;: &quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->+s);<!-- raw HTML omitted -->        }<!-- raw HTML omitted --><!-- raw HTML omitted -->    }<!-- raw HTML omitted --><!-- raw HTML omitted -->    <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->static<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->class<!-- raw HTML omitted --><!-- raw HTML omitted --> Timer <!-- raw HTML omitted --><!-- raw HTML omitted -->implements<!-- raw HTML omitted --><!-- raw HTML omitted --> Runnable {<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> BlockingQueue&lt;Message&gt; queue = <!-- raw HTML omitted --><!-- raw HTML omitted -->new<!-- raw HTML omitted --><!-- raw HTML omitted --> LinkedBlockingQueue&lt;Message&gt;();<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->boolean<!-- raw HTML omitted --><!-- raw HTML omitted --> timing = <!-- raw HTML omitted --><!-- raw HTML omitted -->false<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->private<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->long<!-- raw HTML omitted --><!-- raw HTML omitted --> startTime;<!-- raw HTML omitted --><!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->void<!-- raw HTML omitted --><!-- raw HTML omitted --> sendMessage(Message m) {<!-- raw HTML omitted -->            <!-- raw HTML omitted -->//we don&rsquo;t need to change this implementation as timer is rarely called<!-- raw HTML omitted --><!-- raw HTML omitted -->            queue.add(m);<!-- raw HTML omitted -->        }<!-- raw HTML omitted --><!-- raw HTML omitted -->        <!-- raw HTML omitted --><!-- raw HTML omitted -->public<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->void<!-- raw HTML omitted --><!-- raw HTML omitted --> run() {<!-- raw HTML omitted -->            <!-- raw HTML omitted --><!-- raw HTML omitted -->while<!-- raw HTML omitted --><!-- raw HTML omitted --> (<!-- raw HTML omitted --><!-- raw HTML omitted -->true<!-- raw HTML omitted --><!-- raw HTML omitted -->) {<!-- raw HTML omitted -->                Message m;<!-- raw HTML omitted -->                <!-- raw HTML omitted --><!-- raw HTML omitted -->try<!-- raw HTML omitted --><!-- raw HTML omitted --> {<!-- raw HTML omitted -->                    m = queue.take();<!-- raw HTML omitted -->                    <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (m <!-- raw HTML omitted --><!-- raw HTML omitted -->instanceof<!-- raw HTML omitted --><!-- raw HTML omitted --> StartMessage) {<!-- raw HTML omitted -->                        startTime = System.currentTimeMillis();<!-- raw HTML omitted -->                        timing = <!-- raw HTML omitted --><!-- raw HTML omitted -->true<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->                    } <!-- raw HTML omitted --><!-- raw HTML omitted -->else<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (m <!-- raw HTML omitted --><!-- raw HTML omitted -->instanceof<!-- raw HTML omitted --><!-- raw HTML omitted --> StopMessage) {<!-- raw HTML omitted -->                        <!-- raw HTML omitted --><!-- raw HTML omitted -->long<!-- raw HTML omitted --><!-- raw HTML omitted --> end = System.currentTimeMillis();<!-- raw HTML omitted -->                        System.out.println(<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot;Start=&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->+startTime+<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot; Stop=&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->+end+<!-- raw HTML omitted --><!-- raw HTML omitted -->&quot; Elapsed=&quot;<!-- raw HTML omitted --><!-- raw HTML omitted -->+(end-startTime));<!-- raw HTML omitted -->                        timing = <!-- raw HTML omitted --><!-- raw HTML omitted -->false<!-- raw HTML omitted --><!-- raw HTML omitted -->;                                        <!-- raw HTML omitted -->                    } <!-- raw HTML omitted --><!-- raw HTML omitted -->else<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->if<!-- raw HTML omitted --><!-- raw HTML omitted --> (m <!-- raw HTML omitted --><!-- raw HTML omitted -->instanceof<!-- raw HTML omitted --><!-- raw HTML omitted --> CancelMessage) {<!-- raw HTML omitted -->                        <!-- raw HTML omitted --><!-- raw HTML omitted -->break<!-- raw HTML omitted --><!-- raw HTML omitted -->;<!-- raw HTML omitted -->                    }<!-- raw HTML omitted -->                } <!-- raw HTML omitted --><!-- raw HTML omitted -->catch<!-- raw HTML omitted --><!-- raw HTML omitted --> (InterruptedException e) {<!-- raw HTML omitted -->                    e.printStackTrace();<!-- raw HTML omitted -->                }<!-- raw HTML omitted -->            }<!-- raw HTML omitted -->        }<!-- raw HTML omitted -->    }<!-- raw HTML omitted -->}<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Code<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Spawn<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Send 100M messages<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->Scala Actors<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->15ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->270104ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->SimpleRing<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->11ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->493073ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->OptimizedRing (4 threads)<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->6ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->84727ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->OptimizedRing (5+ threads)<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->5ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->62593ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->OptimizedRing (1 thread)<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->5ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->60660ms<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->I finally saw my 4 cores used! Max multithreaded throughput is achieved at 5 threads. However 1 thread is faster. Is this related to memory bandwith limit?<!-- raw HTML omitted --><!-- raw HTML omitted -->Now I am left wondering if actors are really that important if one can achieve much higher throughput using plain Java and very simple concepts (BlockingQueue, ThreadPoolExecutor). Worse, this test is actually faster with only 1 thread&hellip;</p>

  
</article>
</div>
<p style="text-align:left; width:49%; display: inline-block;"><a href="/page/22/">Previous</a></p>
<p style="text-align:right; width:50%;  display: inline-block;"><a href="/page/24/">Next</a></p>
    </main>

    
      
    
  </body>
</html>
