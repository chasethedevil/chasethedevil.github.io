<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java Haskell on Chase the Devil</title>
    <link>http://chasethedevil.github.io/tags/java-haskell/</link>
    <description>Recent content in Java Haskell on Chase the Devil</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright 2006-2016 Fabien Le Floc&#39;h. This work is licensed under a Creative Commons Attribution 4.0 International License.</copyright>
    <lastBuildDate>Fri, 22 Mar 2013 12:20:00 +0000</lastBuildDate>
    <atom:link href="/tags/java-haskell/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Cracking the Double Precision Gaussian Puzzle</title>
      <link>http://chasethedevil.github.io/post/cracking-the-double-precision-gaussian-puzzle/</link>
      <pubDate>Fri, 22 Mar 2013 12:20:00 +0000</pubDate>
      
      <guid>http://chasethedevil.github.io/post/cracking-the-double-precision-gaussian-puzzle/</guid>
      <description>In my previous post, I stated that some library (SPECFUN by W.D. Cody) computes $$e^{-\frac{x^2}{2}}$$ the following way:
xsq = fint(x * 1.6) / 1.6;
del = (x - xsq) * (x + xsq);
result = exp(-xsq * xsq * 0.5) * exp(-del &amp;nbsp;0.5);
where fint(z) computes the floor of z.
1. Why 1.6?
An integer divided by 1.6 will be an exact representation of the corresponding number in double: 1. <a href="/post/cracking-the-double-precision-gaussian-puzzle/">Read More…</a> <p>Copyright 2006-2016 Fabien Le Floc&#39;h. This work is licensed under a Creative Commons Attribution 4.0 International License.</p></description>
    </item>
    
    <item>
      <title>Haskell Fibonacci Revisited</title>
      <link>http://chasethedevil.github.io/post/haskell-fibonacci-revisited/</link>
      <pubDate>Wed, 12 Dec 2007 17:08:00 +0000</pubDate>
      
      <guid>http://chasethedevil.github.io/post/haskell-fibonacci-revisited/</guid>
      <description>Recently, there was an interesting post about Haskell performance and Haskell parallelization showing Haskell could outperform C on a simple Fibonacci example.
A friend of mine, Peter (that I seem to manage to constantly piss off) thought about it on another level, saying you could achieve a MILLION times better using a direct formula in C or Java, the Binet formula.
I decided to try as the improvement scale seemed a bit surprising. <a href="/post/haskell-fibonacci-revisited/">Read More…</a> <p>Copyright 2006-2016 Fabien Le Floc&#39;h. This work is licensed under a Creative Commons Attribution 4.0 International License.</p></description>
    </item>
    
  </channel>
</rss>
